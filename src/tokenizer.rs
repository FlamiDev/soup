use crate::compiler_tools::tokenizer::{self, brackets, PositionedToken};

#[derive(Debug, PartialEq, Clone)]
pub enum Token {
    TypeKeyword,
    LetKeyword,
    MatchKeyword,
    DocKeyword,
    TestKeyword,
    AssertKeyword,
    MockKeyword,
    ImportKeyword,
    ExportKeyword,
    TraitKeyword,
    RetKeyword,
    EqualsSign,
    DoubleEqualsSign,
    NotEqualsSign,
    LessThanSign,
    GreaterThanSign,
    LessThanEqualsSign,
    GreaterThanEqualsSign,
    SpreadRangeOperator,
    VerticalBar,
    ArrowLeft,
    ArrowRight,
    ArrayOpen,
    ArrayClose,
    Array(Vec<PositionedToken<Token>>),
    ParenOpen,
    ParenClose,
    Parens(Vec<PositionedToken<Token>>),
    BraceOpen,
    BraceClose,
    Braces(Vec<PositionedToken<Token>>),
    Comma,
    Dot,
    Colon,
    Semicolon,
    Plus,
    Minus,
    Asterisk,
    Slash,
    Percent,
    Underscore,
    Bang,
    QuestionMark,
    NewLine,
    Type(String),
    Name(String),
    Int(i64),
    Float(f64),
    String(String),
    Invalid(String),
}

pub fn parse(input: String) -> Vec<PositionedToken<Token>> {
    tokenizer::parse(
        input,
        |word| match word {
            "type" => Token::TypeKeyword,
            "let" => Token::LetKeyword,
            "match" => Token::MatchKeyword,
            "doc" => Token::DocKeyword,
            "test" => Token::TestKeyword,
            "assert" => Token::AssertKeyword,
            "mock" => Token::MockKeyword,
            "import" => Token::ImportKeyword,
            "export" => Token::ExportKeyword,
            "trait" => Token::TraitKeyword,
            "ret" => Token::RetKeyword,
            "=" => Token::EqualsSign,
            "==" => Token::DoubleEqualsSign,
            "!=" => Token::NotEqualsSign,
            "<" => Token::LessThanSign,
            ">" => Token::GreaterThanSign,
            "<=" => Token::LessThanEqualsSign,
            ">=" => Token::GreaterThanEqualsSign,
            ".." => Token::SpreadRangeOperator,
            "|" => Token::VerticalBar,
            "<-" => Token::ArrowLeft,
            "->" => Token::ArrowRight,
            "[" => Token::ArrayOpen,
            "]" => Token::ArrayClose,
            "(" => Token::ParenOpen,
            ")" => Token::ParenClose,
            "{" => Token::BraceOpen,
            "}" => Token::BraceClose,
            "," => Token::Comma,
            "." => Token::Dot,
            ":" => Token::Colon,
            ";" => Token::Semicolon,
            "+" => Token::Plus,
            "-" => Token::Minus,
            "*" => Token::Asterisk,
            "/" => Token::Slash,
            "%" => Token::Percent,
            "_" => Token::Underscore,
            "!" => Token::Bang,
            "?" => Token::QuestionMark,
            "\n" => Token::NewLine,
            other => tokenizer::other(
                other,
                Token::Type,
                Token::Name,
                Token::Int,
                Token::Float,
                Token::String,
                Token::Invalid,
            ),
        },
        vec![
            brackets(Token::ParenOpen, Token::ParenClose, Token::Parens),
            brackets(Token::BraceOpen, Token::BraceClose, Token::Braces),
            brackets(Token::ArrayOpen, Token::ArrayClose, Token::Array),
        ],
        Token::Invalid,
    )
}
