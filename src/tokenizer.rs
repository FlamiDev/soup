use crate::compiler_tools::tokenizer::{self, PositionedToken};

#[derive(Debug, PartialEq, Clone)]
pub enum Token {
    TypeKeyword,
    LetKeyword,
    MatchKeyword,
    DocKeyword,
    TestKeyword,
    AssertKeyword,
    MockKeyword,
    ImportKeyword,
    ExportKeyword,
    TraitKeyword,
    EqualsSign,
    DoubleEqualsSign,
    NotEqualsSign,
    LessThanSign,
    GreaterThanSign,
    LessThanEqualsSign,
    GreaterThanEqualsSign,
    SpreadRangeOperator,
    VerticalBar,
    ArrowRight,
    ArrayOpen,
    ArrayClose,
    ParenOpen,
    ParenClose,
    BraceOpen,
    BraceClose,
    Comma,
    Dot,
    Colon,
    Semicolon,
    Plus,
    Minus,
    Asterisk,
    Slash,
    Percent,
    Underscore,
    Bang,
    QuestionMark,
    NewLine,
    Type(String),
    Name(String),
    Int(i64),
    Float(f64),
    String(String),
    Invalid(String),
}

pub fn parse(input: &str) -> Vec<PositionedToken<Token>> {
    tokenizer::parse(input, |word| match word {
        "type" => Token::TypeKeyword,
        "let" => Token::LetKeyword,
        "match" => Token::MatchKeyword,
        "doc" => Token::DocKeyword,
        "test" => Token::TestKeyword,
        "assert" => Token::AssertKeyword,
        "mock" => Token::MockKeyword,
        "import" => Token::ImportKeyword,
        "export" => Token::ExportKeyword,
        "trait" => Token::TraitKeyword,
        "=" => Token::EqualsSign,
        "==" => Token::DoubleEqualsSign,
        "!=" => Token::NotEqualsSign,
        "<" => Token::LessThanSign,
        ">" => Token::GreaterThanSign,
        "<=" => Token::LessThanEqualsSign,
        ">=" => Token::GreaterThanEqualsSign,
        ".." => Token::SpreadRangeOperator,
        "|" => Token::VerticalBar,
        "->" => Token::ArrowRight,
        "[" => Token::ArrayOpen,
        "]" => Token::ArrayClose,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "{" => Token::BraceOpen,
        "}" => Token::BraceClose,
        "," => Token::Comma,
        "." => Token::Dot,
        ":" => Token::Colon,
        ";" => Token::Semicolon,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "_" => Token::Underscore,
        "!" => Token::Bang,
        "?" => Token::QuestionMark,
        "\n" => Token::NewLine,
        other => tokenizer::other(
            other,
            |t| Token::Type(t),
            |n| Token::Name(n),
            |i| Token::Int(i),
            |f| Token::Float(f),
            |s| Token::String(s),
            |msg| Token::Invalid(msg),
        ),
    })
}
